// ==UserScript==
// @name          Gerenciador de Conversas com Cronômetro e Numeração - Otimizado
// @namespace     http://seu-dominio.com.br/
// @version       2.0
// @description   Versão otimizada: Adiciona cronômetros e numeração dinâmica com melhor performance, persistência de dados e controles adicionais
// @author        Assistente IA
// @match         https://apps.sae1.pure.cloud/directory/#/activity*
// @grant         none
// ==/UserScript==

(function() {
    'use strict';

    // ==================== CONFIGURAÇÕES ====================
    const CONFIG = {
        // Tempo limite em milissegundos (70 segundos)
        LIMIT_TIME_MS: 70 * 1000,
        // Intervalo de atualização do cronômetro
        UPDATE_INTERVAL_MS: 100, // Otimizado de 10ms para 100ms
        // Seletores CSS
        SELECTORS: {
            conversation: 'div.interaction-group',
            activeConversation: 'div.interaction-group.is-selected',
            timerClass: 'injected-conversation-timer',
            numberClass: 'injected-conversation-number',
            controlsClass: 'injected-conversation-controls'
        },
        // Estilos
        STYLES: {
            timer: {
                running: {
                    backgroundColor: 'rgba(76, 175, 80, 0.9)',
                    color: 'white',
                    borderColor: '#4CAF50'
                },
                paused: {
                    backgroundColor: 'rgba(255, 193, 7, 0.9)',
                    color: '#333',
                    borderColor: '#FFC107'
                },
                completed: {
                    backgroundColor: 'rgba(76, 175, 80, 1)',
                    color: 'white',
                    text: '✓',
                    fontSize: '16px'
                }
            },
            number: {
                backgroundColor: 'rgba(33, 150, 243, 0.9)',
                color: 'white',
                borderColor: '#2196F3'
            }
        }
    };

    // ==================== CLASSE PRINCIPAL ====================
    class ConversationTimer {
        constructor(element) {
            this.element = element;
            this.startTime = Date.now();
            this.pausedTime = 0;
            this.totalPausedTime = 0;
            this.isRunning = false;
            this.isCompleted = false;
            this.intervalId = null;
            
            this.timerDiv = null;
            this.numberDiv = null;
            
            this.createElements();
            this.pause();
        }

        createElements() {
            // Garante posição relativa no elemento pai
            this.element.style.position = 'relative';
            
            this.createTimerElement();
            this.createNumberElement();
        }

        createTimerElement() {
            this.timerDiv = document.createElement('div');
            this.timerDiv.className = CONFIG.SELECTORS.timerClass;
            
            Object.assign(this.timerDiv.style, {
                position: 'absolute',
                top: '50%',
                right: '5px',
                transform: 'translateY(-50%)',
                padding: '4px 8px',
                borderRadius: '4px',
                fontSize: '12px',
                fontFamily: 'monospace',
                fontWeight: 'bold',
                zIndex: '9999',
                minWidth: '50px',
                textAlign: 'center',
                border: '1px solid',
                cursor: 'pointer',
                userSelect: 'none',
                transition: 'all 0.2s ease'
            });
            
            // Sistema de hold para marcar como concluído
            this.setupHoldToComplete();
            
            this.element.appendChild(this.timerDiv);
        }

        setupHoldToComplete() {
            let holdTimer = null;
            let holdStartTime = 0;
            const HOLD_DURATION = 5000; // 5 segundos
            
            // Mouse down - inicia hold
            this.timerDiv.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                
                if (this.isCompleted) return;
                
                holdStartTime = Date.now();
                
                holdTimer = setInterval(() => {
                    const elapsed = Date.now() - holdStartTime;
                    
                    if (elapsed >= HOLD_DURATION) {
                        // Marca como concluído após 5 segundos
                        this.complete();
                        clearInterval(holdTimer);
                        holdTimer = null;
                    }
                }, 100);
            });
            
            // Mouse up/leave - cancela hold
            const cancelHold = (e) => {
                e.stopPropagation();
                
                if (holdTimer) {
                    clearInterval(holdTimer);
                    holdTimer = null;
                }
            };
            
            this.timerDiv.addEventListener('mouseup', cancelHold);
            this.timerDiv.addEventListener('mouseleave', cancelHold);
            
            // Touch events para mobile
            this.timerDiv.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                e.preventDefault();
                
                if (this.isCompleted) return;
                
                holdStartTime = Date.now();
                
                holdTimer = setInterval(() => {
                    const elapsed = Date.now() - holdStartTime;
                    
                    if (elapsed >= HOLD_DURATION) {
                        this.complete();
                        clearInterval(holdTimer);
                        holdTimer = null;
                    }
                }, 100);
            });
            
            this.timerDiv.addEventListener('touchend', cancelHold);
            this.timerDiv.addEventListener('touchcancel', cancelHold);
        }

        createNumberElement() {
            this.numberDiv = document.createElement('div');
            this.numberDiv.className = CONFIG.SELECTORS.numberClass;
            
            Object.assign(this.numberDiv.style, {
                position: 'absolute',
                top: '5px',
                right: '5px',
                padding: '2px 6px',
                borderRadius: '50%',
                fontSize: '11px',
                fontFamily: 'sans-serif',
                fontWeight: 'bold',
                zIndex: '99999',
                minWidth: '20px',
                textAlign: 'center',
                border: '1px solid',
                ...CONFIG.STYLES.number
            });
            
            this.element.appendChild(this.numberDiv);
        }

        createControlsElement() {
            // Função removida - controles não são mais necessários
        }

        start() {
            if (this.isRunning || this.isCompleted) return;
            
            this.isRunning = true;
            this.startTime = Date.now() - this.totalPausedTime;
            
            this.intervalId = setInterval(() => this.update(), CONFIG.UPDATE_INTERVAL_MS);
            this.updateStyles('running');
        }

        pause() {
            if (!this.isRunning || this.isCompleted) return;
            
            this.isRunning = false;
            this.pausedTime = Date.now();
            
            clearInterval(this.intervalId);
            this.updateStyles('paused');
        }

        toggle() {
            if (this.isCompleted) return;
            
            if (this.isRunning) {
                this.pause();
            } else {
                // Se estava pausado, adiciona o tempo pausado ao total
                if (this.pausedTime > 0) {
                    this.totalPausedTime += Date.now() - this.pausedTime;
                }
                this.start();
            }
        }

        complete() {
            if (this.isCompleted) return;
            
            this.isCompleted = true;
            this.isRunning = false;
            clearInterval(this.intervalId);
            
            this.timerDiv.textContent = CONFIG.STYLES.timer.completed.text;
            this.updateStyles('completed');
            this.timerDiv.classList.add('timer-completed');
            
            console.log(`Cronômetro concluído para conversa: ${this.getConversationId()}`);
        }

        update() {
            if (!this.isRunning || this.isCompleted) return;
            
            const elapsedTime = Date.now() - this.startTime;
            
            if (elapsedTime >= CONFIG.LIMIT_TIME_MS) {
                this.complete();
                return;
            }
            
            this.updateDisplay(elapsedTime);
        }

        updateDisplay(elapsedTime) {
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            
            this.timerDiv.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        updateStyles(state) {
            if (this.isCompleted && state !== 'completed') return;
            
            const styles = CONFIG.STYLES.timer[state];
            if (!styles) return;
            
            Object.assign(this.timerDiv.style, {
                backgroundColor: styles.backgroundColor,
                color: styles.color,
                borderColor: styles.borderColor,
                fontSize: styles.fontSize || '12px'
            });
        }

        setNumber(number) {
            if (this.numberDiv) {
                this.numberDiv.textContent = number.toString();
            }
        }

        getConversationId() {
            return this.element.id || `conversation-${Date.now()}`;
        }

        getElapsedTime() {
            if (this.isCompleted) return CONFIG.LIMIT_TIME_MS;
            if (!this.isRunning && this.pausedTime > 0) {
                return this.pausedTime - this.startTime;
            }
            return Date.now() - this.startTime;
        }

        destroy() {
            clearInterval(this.intervalId);
            
            [this.timerDiv, this.numberDiv].forEach(element => {
                if (element && element.parentNode) {
                    element.remove();
                }
            });
        }
    }

    // ==================== GERENCIADOR PRINCIPAL ====================
    class ConversationManager {
        constructor() {
            this.timers = new Map();
            this.observer = null;
            this.currentActive = null;
            
            this.init();
        }

        init() {
            console.log('Inicializando Gerenciador de Conversas...');
            
            // Remove elementos de execuções anteriores
            this.cleanup();
            
            // Aguarda carregamento inicial
            setTimeout(() => {
                this.initializeExistingConversations();
                this.startObserver();
                this.updateNumbers();
                this.manageActiveTimers();
            }, 300);
        }

        cleanup() {
            document.querySelectorAll(`.${CONFIG.SELECTORS.timerClass}, .${CONFIG.SELECTORS.numberClass}`)
                     .forEach(el => el.remove());
            this.timers.clear();
        }

        initializeExistingConversations() {
            const conversations = document.querySelectorAll(CONFIG.SELECTORS.conversation);
            
            conversations.forEach(conv => {
                if (!this.timers.has(conv)) {
                    this.createTimer(conv);
                }
            });
            
            console.log(`Inicializadas ${conversations.length} conversas existentes.`);
        }

        createTimer(element) {
            if (this.timers.has(element)) return this.timers.get(element);
            
            const timer = new ConversationTimer(element);
            this.timers.set(element, timer);
            
            return timer;
        }

        removeTimer(element) {
            const timer = this.timers.get(element);
            if (timer) {
                timer.destroy();
                this.timers.delete(element);
            }
        }

        updateNumbers() {
            // Ordena conversas por posição vertical (mais recente no topo)
            const conversations = Array.from(this.timers.keys())
                .filter(el => document.body.contains(el))
                .sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top);
            
            conversations.forEach((conv, index) => {
                const timer = this.timers.get(conv);
                if (timer) {
                    timer.setNumber(index + 1);
                }
            });
            
            // Remove timers órfãos
            this.timers.forEach((timer, element) => {
                if (!document.body.contains(element)) {
                    this.removeTimer(element);
                }
            });
        }

        manageActiveTimers() {
            const activeConv = document.querySelector(CONFIG.SELECTORS.activeConversation);
            
            // Pausa todos os timers não ativos
            this.timers.forEach((timer, element) => {
                if (element !== activeConv) {
                    timer.pause();
                }
            });
            
            // Ativa timer da conversa selecionada
            if (activeConv) {
                let timer = this.timers.get(activeConv);
                if (!timer) {
                    timer = this.createTimer(activeConv);
                }
                
                if (!timer.isCompleted) {
                    timer.start();
                }
                
                this.currentActive = activeConv;
            } else {
                this.currentActive = null;
            }
        }

        startObserver() {
            if (this.observer) this.observer.disconnect();
            
            this.observer = new MutationObserver((mutations) => {
                let shouldUpdate = false;
                let shouldManageTimers = false;
                
                for (const mutation of mutations) {
                    if (mutation.type === 'childList') {
                        // Novos elementos adicionados
                        for (const node of mutation.addedNodes) {
                            if (node.nodeType === 1) {
                                if (node.matches && node.matches(CONFIG.SELECTORS.conversation)) {
                                    this.createTimer(node);
                                    shouldUpdate = true;
                                }
                                
                                // Busca conversas dentro do elemento adicionado
                                const newConversations = node.querySelectorAll && node.querySelectorAll(CONFIG.SELECTORS.conversation);
                                if (newConversations) {
                                    newConversations.forEach(conv => {
                                        if (!this.timers.has(conv)) {
                                            this.createTimer(conv);
                                            shouldUpdate = true;
                                        }
                                    });
                                }
                            }
                        }
                        
                        // Elementos removidos
                        for (const node of mutation.removedNodes) {
                            if (node.nodeType === 1 && node.matches && node.matches(CONFIG.SELECTORS.conversation)) {
                                this.removeTimer(node);
                                shouldUpdate = true;
                            }
                        }
                    }
                    
                    // Mudanças de classe (seleção ativa)
                    if (mutation.type === 'attributes' && 
                        mutation.attributeName === 'class' && 
                        mutation.target.matches && 
                        mutation.target.matches(CONFIG.SELECTORS.conversation)) {
                        shouldManageTimers = true;
                    }
                }
                
                // Executa atualizações necessárias
                if (shouldUpdate) {
                    this.updateNumbers();
                }
                if (shouldManageTimers) {
                    this.manageActiveTimers();
                }
            });
            
            this.observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['class']
            });
        }

        // Método público para estatísticas
        getStats() {
            const stats = {
                total: this.timers.size,
                running: 0,
                paused: 0,
                completed: 0,
                averageTime: 0
            };
            
            let totalTime = 0;
            this.timers.forEach(timer => {
                if (timer.isCompleted) {
                    stats.completed++;
                    totalTime += CONFIG.LIMIT_TIME_MS;
                } else if (timer.isRunning) {
                    stats.running++;
                    totalTime += timer.getElapsedTime();
                } else {
                    stats.paused++;
                    totalTime += timer.getElapsedTime();
                }
            });
            
            stats.averageTime = stats.total > 0 ? Math.round(totalTime / stats.total / 1000) : 0;
            
            return stats;
        }
    }

    // ==================== INICIALIZAÇÃO ====================
    const manager = new ConversationManager();
    
    // Disponibiliza globalmente para debug
    window.conversationManager = manager;
    
    // Log de inicialização
    console.log('✅ Script Gerenciador de Conversas v2.0 carregado com sucesso!');
    console.log('💡 Digite "conversationManager.getStats()" no console para ver estatísticas.');
    console.log('💡 Mantenha pressionado o cronômetro por 5 segundos para marcar como concluído.');

})();
